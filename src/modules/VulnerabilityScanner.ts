import { SessionManager, type Vulnerability } from './SessionManager';

interface TerminalLine {
  id: string;
  content: string;
  type: 'system' | 'user' | 'output' | 'error' | 'success' | 'warning';
  timestamp?: string;
}

export class VulnerabilityScanner {
  private static delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  static async performVulnScan(
    args: string[],
    addLine: (content: string, type: TerminalLine['type']) => void,
    addLines: (lines: TerminalLine[]) => void
  ): Promise<void> {
    const sessionData = SessionManager.getSessionData();

    if (!sessionData.target && args.length < 2) {
      addLine('[ERROR] No target specified. Run scan command first or provide target.', 'error');
      addLine('[INFO] Usage: vuln <target> [-p <port>] [-deep]', 'output');
      return;
    }

    const target = args[1] || sessionData.target;
    let specificPort = '';
    let deepScan = false;

    // Parse arguments
    for (let i = 2; i < args.length; i++) {
      if (args[i] === '-p' && args[i + 1]) {
        specificPort = args[i + 1];
        i++;
      } else if (args[i] === '-deep') {
        deepScan = true;
      }
    }

    addLine(`[VULN-SCAN] Initializing vulnerability assessment on ${target}`, 'system');
    if (specificPort) {
      addLine(`[VULN-SCAN] Focusing on port: ${specificPort}`, 'system');
    }
    if (deepScan) {
      addLine('[VULN-SCAN] Deep scan mode enabled - checking for zero-days', 'warning');
    }
    addLine('[VULN-SCAN] Cross-referencing with exploit database...', 'warning');

    await this.simulateVulnScanProgress(deepScan, addLine);

    const vulnerabilities = this.generateVulnerabilities(sessionData.scanResults, specificPort, deepScan);
    SessionManager.setVulnerabilities(vulnerabilities);

    this.displayVulnerabilities(vulnerabilities, addLines);
  }

  private static async simulateVulnScanProgress(
    deepScan: boolean,
    addLine: (content: string, type: TerminalLine['type']) => void
  ): Promise<void> {
    addLine('[VULN-SCAN] Loading CVE database...', 'warning');
    await this.delay(1000);
    
    addLine('[VULN-SCAN] Analyzing service versions...', 'warning');
    await this.delay(1500);
    
    addLine('[VULN-SCAN] Checking for known exploits...', 'warning');
    await this.delay(1200);

    if (deepScan) {
      addLine('[VULN-SCAN] Performing deep vulnerability analysis...', 'warning');
      await this.delay(2000);
      addLine('[VULN-SCAN] Checking for configuration weaknesses...', 'warning');
      await this.delay(1500);
    }

    addLine('[VULN-SCAN] Correlating findings...', 'warning');
    await this.delay(800);
  }

  private static displayVulnerabilities(
    vulnerabilities: Vulnerability[],
    addLines: (lines: TerminalLine[]) => void
  ): void {
    const criticalVulns = vulnerabilities.filter(v => v.severity === 'CRITICAL');
    const highVulns = vulnerabilities.filter(v => v.severity === 'HIGH');
    const mediumVulns = vulnerabilities.filter(v => v.severity === 'MEDIUM');

    const vulnLines: TerminalLine[] = [
      { id: Date.now().toString(), content: '', type: 'output' },
      { id: (Date.now() + 1).toString(), content: '╔═══════════════════════════════════════════════════════════╗', type: 'error' },
      { id: (Date.now() + 2).toString(), content: '║                 VULNERABILITIES DETECTED                  ║', type: 'error' },
      { id: (Date.now() + 3).toString(), content: '╚═══════════════════════════════════════════════════════════╝', type: 'error' },
      { id: (Date.now() + 4).toString(), content: '', type: 'output' },
      { 
        id: (Date.now() + 5).toString(), 
        content: `SUMMARY: ${criticalVulns.length} Critical | ${highVulns.length} High | ${mediumVulns.length} Medium`, 
        type: 'warning' 
      },
      { id: (Date.now() + 6).toString(), content: '', type: 'output' },
    ];

    let lineId = Date.now() + 10;

    // Group vulnerabilities by severity
    [
      { severity: 'CRITICAL', vulns: criticalVulns, color: 'error' as const },
      { severity: 'HIGH', vulns: highVulns, color: 'warning' as const },
      { severity: 'MEDIUM', vulns: mediumVulns, color: 'output' as const }
    ].forEach(group => {
      if (group.vulns.length > 0) {
        vulnLines.push({
          id: (lineId++).toString(),
          content: `═══ ${group.severity} SEVERITY ═══`,
          type: group.color
        });

        group.vulns.forEach((vuln) => {
          vulnLines.push({
            id: (lineId++).toString(),
            content: `[${vuln.severity}] ${vuln.cve} - ${vuln.title}`,
            type: group.color
          });
          vulnLines.push({
            id: (lineId++).toString(),
            content: `         Port: ${vuln.port || 'Multiple'} | ${vuln.description}`,
            type: 'output'
          });
          vulnLines.push({
            id: (lineId++).toString(),
            content: '',
            type: 'output'
          });
        });
      }
    });

    if (vulnerabilities.length > 0) {
      vulnLines.push({
        id: (lineId++).toString(),
        content: '[INFO] Use "exploit <CVE-ID>" to attempt exploitation of discovered vulnerabilities.',
        type: 'output'
      });
    } else {
      vulnLines.push({
        id: (lineId++).toString(),
        content: '[INFO] No critical vulnerabilities detected. Target appears to be well-patched.',
        type: 'success'
      });
    }

    addLines(vulnLines);
  }

  private static generateVulnerabilities(scanResults: any[], specificPort?: string, deepScan?: boolean): Vulnerability[] {
    const vulnDatabase = [
      {
        cve: 'CVE-2021-44228',
        title: 'Log4Shell RCE',
        severity: 'CRITICAL' as const,
        port: '8080',
        description: 'Remote code execution in Apache Log4j 2.x'
      },
      {
        cve: 'CVE-2022-22965',
        title: 'Spring4Shell RCE',
        severity: 'CRITICAL' as const,
        port: '8080',
        description: 'Remote code execution in Spring Framework'
      },
      {
        cve: 'CVE-2021-34527',
        title: 'PrintNightmare',
        severity: 'HIGH' as const,
        port: '445',
        description: 'Windows Print Spooler privilege escalation'
      },
      {
        cve: 'CVE-2019-0708',
        title: 'BlueKeep RDP RCE',
        severity: 'HIGH' as const,
        port: '3389',
        description: 'Remote Desktop Services remote code execution'
      },
      {
        cve: 'CVE-2020-1472',
        title: 'Zerologon',
        severity: 'CRITICAL' as const,
        port: '445',
        description: 'Netlogon privilege escalation vulnerability'
      },
      {
        cve: 'CVE-2021-3156',
        title: 'Sudo Baron Samedit',
        severity: 'HIGH' as const,
        port: '22',
        description: 'Local privilege escalation via sudo'
      },
      {
        cve: 'CVE-2022-0847',
        title: 'Dirty Pipe',
        severity: 'HIGH' as const,
        port: '22',
        description: 'Linux kernel privilege escalation'
      },
      {
        cve: 'CVE-2021-4034',
        title: 'PwnKit',
        severity: 'HIGH' as const,
        port: '22',
        description: 'PolicyKit privilege escalation'
      },
      {
        cve: 'CVE-2022-26134',
        title: 'Confluence RCE',
        severity: 'CRITICAL' as const,
        port: '8080',
        description: 'Atlassian Confluence remote code execution'
      },
      {
        cve: 'CVE-2021-40438',
        title: 'Apache HTTP Server SSRF',
        severity: 'MEDIUM' as const,
        port: '80',
        description: 'Server-Side Request Forgery in mod_proxy'
      }
    ];

    let selectedVulns = vulnDatabase;

    // Filter by specific port if provided
    if (specificPort) {
      selectedVulns = vulnDatabase.filter(v => v.port === specificPort);
    }

    // Determine number of vulnerabilities based on scan type
    let vulnCount = Math.floor(Math.random() * 3) + 2; // 2-4 vulnerabilities
    if (deepScan) {
      vulnCount = Math.floor(Math.random() * 4) + 4; // 4-7 vulnerabilities
    }

    // Return random selection
    return selectedVulns
      .sort(() => Math.random() - 0.5)
      .slice(0, Math.min(vulnCount, selectedVulns.length));
  }
}