import { SessionManager } from './SessionManager';

interface TerminalLine {
  id: string;
  content: string;
  type: 'system' | 'user' | 'output' | 'error' | 'success' | 'warning';
  timestamp?: string;
}

export class ExploitModule {
  private static delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  static async attemptExploit(
    args: string[],
    addLine: (content: string, type: TerminalLine['type']) => void,
    addLines: (lines: TerminalLine[]) => void
  ): Promise<void> {
    if (args.length < 2) {
      addLine('[ERROR] Usage: exploit <CVE-ID> [-p <port>] [-payload <type>]', 'error');
      addLine('[INFO] Example: exploit CVE-2021-44228 -p 8080 -payload reverse_shell', 'output');
      return;
    }

    const sessionData = SessionManager.getSessionData();
    
    // Clean up CVE ID - remove angle brackets and extra spaces
    const rawCveId = args[1];
    const cveId = rawCveId.replace(/[<>]/g, '').trim();
    
    let targetPort = '';
    let payloadType = 'default';

    // Parse arguments
    for (let i = 2; i < args.length; i++) {
      if (args[i] === '-p' && args[i + 1]) {
        targetPort = args[i + 1];
        i++;
      } else if (args[i] === '-payload' && args[i + 1]) {
        payloadType = args[i + 1];
        i++;
      }
    }

    const vulnerability = sessionData.vulnerabilities.find(v => v.cve === cveId);

    if (!vulnerability) {
      addLine(`[ERROR] CVE ${cveId} not found in current assessment.`, 'error');
      if (sessionData.vulnerabilities.length > 0) {
        addLine('[INFO] Available CVEs from last scan:', 'output');
        addLine('', 'output');
        sessionData.vulnerabilities.forEach(v => {
          const severityColor = v.severity === 'CRITICAL' ? 'error' : 
                               v.severity === 'HIGH' ? 'warning' : 'output';
          addLine(`       ${v.cve} - ${v.title}`, severityColor);
        });
      } else {
        addLine('[INFO] Run "vuln <target>" command first to identify vulnerabilities.', 'output');
      }
      return;
    }

    // Start exploitation process
    addLine(`[EXPLOIT] Initializing exploitation of ${cveId}`, 'warning');
    addLine(`[EXPLOIT] Target: ${sessionData.target} | Vulnerability: ${vulnerability.title}`, 'system');
    if (targetPort) {
      addLine(`[EXPLOIT] Targeting port: ${targetPort}`, 'system');
    }
    addLine(`[EXPLOIT] Payload type: ${payloadType}`, 'system');
    addLine('', 'output');

    await this.simulateExploitation(vulnerability, payloadType, addLine);

    // Determine success rate based on vulnerability severity
    const baseSuccessRate = vulnerability.severity === 'CRITICAL' ? 0.8 : 
                           vulnerability.severity === 'HIGH' ? 0.7 : 0.6;
    
    const success = Math.random() < baseSuccessRate;

    if (success) {
      await this.handleSuccessfulExploit(cveId, vulnerability, payloadType, addLine, addLines);
    } else {
      await this.handleFailedExploit(vulnerability, addLine);
    }
  }

  private static async simulateExploitation(
    vulnerability: any,
    payloadType: string,
    addLine: (content: string, type: TerminalLine['type']) => void
  ): Promise<void> {
    addLine('[EXPLOIT] Loading exploit modules...', 'warning');
    await this.delay(1000);
    
    addLine('[EXPLOIT] Crafting payload...', 'warning');
    await this.delay(800);
    
    addLine(`[EXPLOIT] Generating ${payloadType} payload for ${vulnerability.cve}...`, 'warning');
    await this.delay(1200);
    
    addLine('[EXPLOIT] Establishing connection to target...', 'system');
    await this.delay(1500);
    
    addLine('[EXPLOIT] Sending exploit payload...', 'warning');
    await this.delay(2000);
    
    addLine('[EXPLOIT] Waiting for callback...', 'system');
    await this.delay(1800);
  }

  private static async handleSuccessfulExploit(
    cveId: string,
    vulnerability: any,
    payloadType: string,
    addLine: (content: string, type: TerminalLine['type']) => void,
    addLines: (lines: TerminalLine[]) => void
  ): Promise<void> {
    SessionManager.setCompromisedShell(true);
    SessionManager.addExploit(cveId);
    
    const successLines: TerminalLine[] = [
      { id: Date.now().toString(), content: '╔═══════════════════════════════════════════════════════════╗', type: 'success' },
      { id: (Date.now() + 1).toString(), content: '║                  EXPLOITATION SUCCESSFUL                  ║', type: 'success' },
      { id: (Date.now() + 2).toString(), content: '╚═══════════════════════════════════════════════════════════╝', type: 'success' },
      { id: (Date.now() + 3).toString(), content: '', type: 'output' },
      { id: (Date.now() + 4).toString(), content: '[+] Exploit successful!', type: 'success' },
      { id: (Date.now() + 5).toString(), content: '[+] Shell acquired on target system', type: 'success' },
    ];

    // Add specific success messages based on vulnerability type
    if (vulnerability.severity === 'CRITICAL') {
      successLines.push({ 
        id: (Date.now() + 6).toString(), 
        content: '[+] SYSTEM level access achieved', 
        type: 'success' 
      });
    } else {
      successLines.push({ 
        id: (Date.now() + 6).toString(), 
        content: '[+] User level access achieved', 
        type: 'success' 
      });
    }

    if (payloadType === 'reverse_shell') {
      successLines.push({ 
        id: (Date.now() + 7).toString(), 
        content: '[+] Reverse shell connection established', 
        type: 'success' 
      });
    }

    successLines.push(
      { id: (Date.now() + 8).toString(), content: '', type: 'output' },
      { id: (Date.now() + 9).toString(), content: '╭─ SHELL ACCESS ─────────────────────────────────────────────╮', type: 'system' },
      { id: (Date.now() + 10).toString(), content: '│ victim-machine $> _                                        │', type: 'system' },
      { id: (Date.now() + 11).toString(), content: '╰────────────────────────────────────────────────────────────╯', type: 'system' },
      { id: (Date.now() + 12).toString(), content: '', type: 'output' },
      { id: (Date.now() + 13).toString(), content: 'Available commands: whoami, id, pwd, ls, cat, ps, netstat, exit', type: 'output' },
      { id: (Date.now() + 14).toString(), content: '', type: 'output' },
    );

    addLines(successLines);
  }

  private static async handleFailedExploit(
    vulnerability: any,
    addLine: (content: string, type: TerminalLine['type']) => void
  ): Promise<void> {
    const failureReasons = [
      'Target may be patched or protected',
      'Firewall or IDS detected the attack',
      'Service version mismatch',
      'Insufficient privileges for exploitation',
      'Network conditions prevented successful exploitation'
    ];

    const reason = failureReasons[Math.floor(Math.random() * failureReasons.length)];

    addLine('[-] Exploitation failed!', 'error');
    addLine(`[-] Reason: ${reason}`, 'error');
    addLine('[!] Consider alternative attack vectors or payloads.', 'warning');
    
    // Provide suggestions based on vulnerability
    if (vulnerability.severity === 'CRITICAL') {
      addLine('[SUGGESTION] Try different payload types or manual exploitation.', 'output');
    } else {
      addLine('[SUGGESTION] Look for privilege escalation opportunities.', 'output');
    }
  }

  static async handleShellCommand(
    command: string,
    addLine: (content: string, type: TerminalLine['type']) => void
  ): Promise<void> {
    const args = command.trim().split(' ');
    const cmd = args[0];

    await this.delay(300);

    switch (cmd) {
      case 'whoami':
        addLine('root', 'success');
        break;
      case 'id':
        addLine('uid=0(root) gid=0(root) groups=0(root)', 'success');
        break;
      case 'pwd':
        addLine('/root', 'output');
        break;
      case 'ls':
        if (args[1] === '-la') {
          addLine('total 48', 'output');
          addLine('drwx------  6 root root 4096 Jan 15 10:30 .', 'output');
          addLine('drwxr-xr-x 18 root root 4096 Jan 10 09:15 ..', 'output');
          addLine('-rw-------  1 root root 1024 Jan 15 10:25 .bash_history', 'output');
          addLine('drwxr-xr-x  3 root root 4096 Jan 12 14:20 Documents', 'output');
          addLine('drwxr-xr-x  2 root root 4096 Jan 14 16:45 Downloads', 'output');
          addLine('-rwxr-xr-x  1 root root 2048 Jan 15 09:30 exploit.py', 'output');
          addLine('-rw-r--r--  1 root root  512 Jan 13 11:20 passwords.txt', 'output');
          addLine('drwx------  2 root root 4096 Jan 15 08:15 sensitive_data', 'output');
        } else {
          addLine('Documents  Downloads  exploit.py  passwords.txt  sensitive_data/', 'output');
        }
        break;
      case 'ps':
        addLine('  PID TTY          TIME CMD', 'output');
        addLine('    1 ?        00:00:01 systemd', 'output');
        addLine('  445 ?        00:00:00 sshd', 'output');
        addLine(' 1337 pts/0    00:00:00 bash', 'output');
        addLine(' 1425 pts/0    00:00:00 ps', 'output');
        break;
      case 'netstat':
        addLine('Active Internet connections (w/o servers)', 'output');
        addLine('Proto Recv-Q Send-Q Local Address           Foreign Address         State', 'output');
        addLine('tcp        0      0 192.168.1.100:22        192.168.1.50:45231      ESTABLISHED', 'output');
        addLine('tcp        0      0 192.168.1.100:80        192.168.1.25:52341      TIME_WAIT', 'output');
        break;
      case 'cat':
        if (args[1] === 'passwords.txt') {
          addLine('# Administrative passwords', 'warning');
          addLine('admin:P@ssw0rd123!', 'warning');
          addLine('user:qwerty456', 'warning');
          addLine('root:toor', 'warning');
          addLine('service:Myp@ss2023', 'warning');
        } else if (args[1] === 'exploit.py') {
          addLine('#!/usr/bin/env python3', 'output');
          addLine('# Custom exploit script', 'output');
          addLine('import socket, subprocess', 'output');
          addLine('# [REDACTED FOR SECURITY]', 'warning');
        } else {
          addLine(`cat: ${args[1] || 'file'}: No such file or directory`, 'error');
        }
        break;
      case 'exit':
        SessionManager.setCompromisedShell(false);
        addLine('[+] Exiting shell. Returning to Himanshu Penetration interface.', 'system');
        addLine('[CLEANUP] Removing traces...', 'warning');
        break;
      default:
        addLine(`bash: ${cmd}: command not found`, 'error');
    }
  }

  static isShellCommand(cmd: string): boolean {
    return ['whoami', 'ls', 'cat', 'pwd', 'exit', 'id', 'ps', 'netstat'].includes(cmd);
  }
}